### Зачем нужен Git?
**Git** — это система управления версиями, предназначенная для отслеживания изменений в исходном коде и координации работы нескольких разработчиков. Она позволяет сохранять разные версии файлов, упрощает совместную работу над проектами и помогает управлять изменениями в коде.

1. **Отслеживание изменений**: Git сохраняет историю изменений, позволяя легко откатиться к предыдущим версиям файлов.
2. **Совместная работа**: Несколько разработчиков могут работать над одним проектом одновременно, не мешая друг другу.
3. **Разделение работы**: Позволяет создавать отдельные ветки для разных задач или фич, не влияя на основную кодовую базу.
4. **Управление конфликтами**: Git помогает решать конфликты, возникающие при одновременной работе над одним и тем же файлом.

### Основные команды Git
1. **git init**: Инициализация нового репозитория.
2. **git clone**: Клонирование существующего репозитория по URL.
3. **git add**: Добавление файла в индекс для следующего коммита.
4. **git commit -m**: Сохранение изменений в репозиторий с описанием.
5. **git status**: Проверка состояния рабочей директории и индекса.
6. **git push**: Отправка изменений из локального репозитория в удаленный.
7. **git pull**: Получение изменений из удаленного репозитория и автоматическое слияние.
8. **git branch**: Просмотр веток; создание и удаление веток.
9. **git checkout**: Переключение между ветками.
10. **git merge**: Слияние указанной ветки с текущей.

### Как работает Git под капотом?
#### 1. Объектная модель
Git использует объектную модель для хранения данных:
- **Blob (Binary Large Object)**: Каждый файл в Git хранится как blob. Blob хранит только содержимое файла, а не имя или метаданные. Каждому blob присваивается уникальный SHA-1 хеш.
- **Tree**: Tree-объект представляет собой каталог и содержит ссылки на blob-объекты и другие tree-объекты. Это позволяет Git поддерживать структуру каталогов и подпапок.
- **Commit**: Commit-объект ссылается на tree-объект и хранит информацию о коммите (автор, дата, сообщение). Каждый коммит также ссылается на родительский коммит (или коммиты в случае слияния), создавая цепочку истории.
#### 2. Индекс (Staging Area)
Перед тем как сделать коммит, изменения сначала добавляются в индекс (или staging area). Индекс служит промежуточным местом, где Git хранит изменения, которые вы хотите включить в следующий коммит. Это позволяет вам контролировать, какие изменения попадают в репозиторий.
#### 3. Коммиты и ветки
Каждый коммит представляет собой снимок состояния всех файлов в проекте на момент его создания. Ветки в Git — это просто указатели на последний коммит в последовательности коммитов. Когда вы создаете новую ветку, Git создает новый указатель, который может указывать на любой коммит в истории.
#### 4. Хеширование и целостность данных
Каждый объект в Git идентифицируется по его SHA-1 хешу. Это обеспечивает целостность данных, так как даже небольшое изменение в содержимом файла приведет к изменению его хеша. Git также использует механизм контроля целостности для проверки данных, что предотвращает их повреждение.
#### 5. Удаленные репозитории
Git позволяет работать с удаленными репозиториями, используя команды `git push` и `git pull`. Когда вы выполняете `push`, изменения из локального репозитория отправляются в удаленный. При выполнении `pull` Git загружает изменения из удаленного репозитория и автоматически сливает их с вашей текущей веткой.
#### 6. Слияние и разрешение конфликтов
Когда несколько разработчиков работают над одним проектом, могут возникнуть конфликты при слиянии изменений. Git предоставляет инструменты для разрешения конфликтов, позволяя разработчикам выбирать, какие изменения сохранить, а какие отклонить.

**Git LFS (Large File Storage)** — это расширение для Git, предназначенное для управления большими файлами, такими как изображения, видео, аудиофайлы и бинарные данные. Стандартный Git неэффективен для хранения больших файлов, так как каждый коммит хранит полную версию файла, что приводит к росту размера репозитория. Git LFS решает эту проблему, сохраняя большие файлы отдельно от основного репозитория и управляя ими более эффективно.

### Как работает Git LFS?
1. **Отслеживание больших файлов**: При помощи команды `git lfs track [путь]` вы можете указать, какие файлы или типы файлов должны отслеживаться с использованием LFS. Это создаст или обновит файл `.gitattributes`, который содержит правила отслеживания.
2. **Замена файлов**: Вместо того чтобы хранить большие файлы в репозитории, Git LFS заменяет их специальными указателями (pointer files). Эти указатели содержат информацию о версии файла, но не сами данные.
3. **Хранение данных**: Сам файл загружается в отдельное хранилище, обычно на сервере, поддерживающем LFS (например, GitHub, GitLab и т.д.). Когда вы коммитите изменения, Git LFS автоматически управляет загрузкой и скачиванием этих файлов.
4. **Загрузка и выгрузка файлов**: При клонировании репозитория или получении изменений с помощью команды `git pull`, Git LFS автоматически загружает нужные версии больших файлов из LFS-хранилища, основываясь на указателях.
5. **Сокращение размера репозитория**: Благодаря тому, что большие файлы хранятся отдельно, размер основного репозитория остается небольшим и управляемым.

### Что такое TFS?

**TFS (Team Foundation Server)** — это система управления версиями и проектами от Microsoft, которая предоставляет инструменты для разработки программного обеспечения и совместной работы команд. TFS включает функции для управления исходным кодом, автоматизации сборок, отслеживания задач и работы с тестированием. С 2018 года TFS стал частью **Azure DevOps Server**, однако многие пользователи все еще используют название TFS.
### Зачем нужен TFS?
1. **Управление версиями**: TFS поддерживает хранение различных версий кода, позволяя командам отслеживать изменения и возвращаться к предыдущим версиям при необходимости.
2. **Совместная работа**: TFS упрощает совместную работу разработчиков, обеспечивая централизованное хранилище для кода и инструментов для совместной работы над проектами.
3. **Интеграция с другими инструментами**: TFS интегрируется с другими продуктами Microsoft и сторонними инструментами, что позволяет легко организовать полный цикл разработки.
4. **Управление проектами**: TFS предоставляет возможности для планирования и отслеживания задач, управления требованиями и оценки рисков.
5. **Непрерывная интеграция и доставка**: TFS поддерживает автоматизацию сборок и развертывания, что упрощает процесс выпуска программного обеспечения.

### Основные компоненты TFS
1. **Source Control (Управление исходным кодом)**: TFS предоставляет функции для хранения и управления версиями исходного кода. Поддерживается как централизованное (TFVC), так и распределенное (Git) управление версиями.
2. **Work Item Tracking (Отслеживание рабочих элементов)**: Позволяет создавать и управлять задачами, ошибками, требованиями и другими элементами проекта.
3. **Build Automation (Автоматизация сборок)**: TFS позволяет настраивать сборочные процессы, что обеспечивает автоматическое создание и тестирование приложения.
4. **Release Management (Управление выпусками)**: Инструменты для автоматизации процесса развертывания приложения на различных средах.
5. **Testing Tools (Инструменты тестирования)**: TFS включает инструменты для управления тестированием, включая планирование тестов и отслеживание результатов.
### Как работает TFS под капотом?

#### 1. Архитектура
TFS основан на клиент-серверной архитектуре, где сервер TFS управляет хранилищем данных, а клиенты (разработчики) используют клиентские приложения для взаимодействия с сервером.
- **TFS Server**: Хранит все данные проекта, включая исходный код, рабочие элементы и результаты тестирования.
- **Клиенты**: Разработчики используют различные клиенты (Visual Studio, TFS Web Portal) для доступа к функциональности TFS.
#### 2. Управление исходным кодом
TFS поддерживает два основных подхода к управлению исходным кодом:
- **TFVC (Team Foundation Version Control)**: Централизованная система управления версиями, где весь код хранится на сервере. Каждый разработчик работает с локальной копией и отправляет изменения на сервер.
- **Git**: TFS также поддерживает Git как распределенную систему управления версиями, что позволяет разработчикам работать с локальными репозиториями и синхронизировать изменения с удаленным репозиторием.
#### 3. Хранилище данных
TFS использует SQL Server для хранения всех данных проекта, включая исходный код, рабочие элементы и результаты тестирования. Данные организованы в различные таблицы, которые обеспечивают быструю и эффективную работу с запросами.
#### 4. Рабочие элементы
В TFS используется система рабочих элементов, которые представляют задачи, ошибки, требования и другие элементы проекта. Каждый рабочий элемент имеет уникальный идентификатор, состояние и связанный с ним процесс работы.
#### 5. Сборки и развертывание
TFS предоставляет механизмы для автоматизации сборок и развертывания. Сборочные определения могут быть настроены для выполнения определенных действий, таких как компиляция кода, запуск тестов и создание артефактов.
#### 6. Безопасность и контроль доступа
TFS предоставляет возможности для управления доступом к проектам и элементам, что позволяет настраивать разрешения для различных пользователей и групп. Это важно для обеспечения безопасности кода и данных проекта.


### Что такое Mercurial?
**Mercurial** — это распределенная система управления версиями, разработанная для упрощения процесса разработки программного обеспечения. Она позволяет отслеживать изменения в коде, управлять версиями файлов и облегчает совместную работу между разработчиками. Mercurial создана с акцентом на производительность, простоту использования и эффективность, что делает её подходящим выбором для проектов любого размера.
### Зачем нужен Mercurial?
1. **Отслеживание изменений**: Mercurial сохраняет полную историю изменений в проекте, что позволяет разработчикам видеть, кто и когда вносил изменения, а также возвращаться к предыдущим версиям.
2. **Совместная работа**: Mercurial позволяет нескольким разработчикам работать над одним проектом одновременно, что снижает вероятность конфликтов и улучшает координацию работы.
3. **Гибкость**: Благодаря своей распределенной архитектуре Mercurial предоставляет возможность работать локально и синхронизировать изменения с удаленным репозиторием по мере необходимости.
4. **Простота использования**: Mercurial имеет простой и понятный интерфейс командной строки, а также доступные графические интерфейсы, что делает его удобным для пользователей с разным уровнем опыта.
5. **Поддержка различных рабочих процессов**: Mercurial поддерживает различные модели рабочего процесса, включая модель "фичи", "багфикс", а также возможности для работы с ветками.

### Основные команды Mercurial
1. **hg init**: Инициализация нового репозитория.
2. **hg clone [URL]**: Клонирование существующего репозитория.
3. **hg add [файл]**: Добавление файла в индекс для следующего коммита.
4. **hg commit -m "[сообщение]"**: Сохранение изменений с описанием в репозиторий.
5. **hg status**: Проверка состояния рабочей директории и индекса.
6. **hg push**: Отправка изменений из локального репозитория в удаленный.
7. **hg pull**: Получение изменений из удаленного репозитория.
8. **hg branch [имя]**: Создание новой ветки.
9. **hg update [ветка]**: Переключение на указанную ветку.
10. **hg merge**: Слияние изменений из одной ветки в текущую.

### Как работает Mercurial под капотом?
#### 1. Архитектура
Mercurial использует распределенную архитектуру, что означает, что каждый разработчик имеет полную копию репозитория на своем компьютере. Это позволяет работать в оффлайне и производить локальные коммиты.
#### 2. Хранилище данных
Mercurial хранит данные в виде объектов, каждый из которых представляет собой:
- **Коммит (Changeset)**: Представляет собой снимок состояния проекта на момент коммита. Каждый коммит содержит информацию о времени, авторе, сообщении коммита и ссылку на предыдущий коммит.
- **Файлы**: Все файлы в проекте хранятся в системе как версии, что позволяет отслеживать изменения в каждом из них.
#### 3. Ветвление и слияние
Mercurial позволяет создавать ветки для управления различными версиями проекта. Ветви могут быть объединены с помощью команды `hg merge`, которая объединяет изменения из одной ветки в другую, разрешая конфликты, если они возникают.
#### 4. Хеширование и целостность данных
Каждый коммит в Mercurial идентифицируется по уникальному хешу (обычно SHA-1), что гарантирует целостность данных. Это позволяет Mercurial отслеживать изменения и предотвращать повреждение данных.
#### 5. Применение патчей
Mercurial предоставляет возможность применения патчей (diffs), что позволяет разработчикам передавать изменения между различными репозиториями без необходимости в прямом доступе к удаленному хранилищу.
#### 6. Инструменты для управления
Mercurial предоставляет инструменты для работы с рабочими элементами и управлением проектами, хотя их функциональность не так развита, как в TFS или других системах управления проектами.