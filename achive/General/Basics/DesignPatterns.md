
**Шаблоны проектирования*** - общепринятые решения типовых задач в разработке в ооп стиле. Их принято делить на три основные категории: **порождающие**, **структурные** и **поведенческие**.

## Порождающие
Эти паттерны связаны с созданием объектов. Они помогают инкапсулировать процесс создания и управлять им.
- **Factory Method (Фабричный метод)**: Определяет интерфейс для создания объектов, но позволяет подклассам изменять тип создаваемого объекта.
- **Abstract Factory (Абстрактная фабрика)**: Позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам.
- **Builder (Строитель)**: Разделяет создание сложного объекта на этапы, позволяя управлять процессом пошагово.
- **Prototype (Прототип)**: Создает новый объект путем клонирования существующего.
- **Singleton (Одиночка)**: Гарантирует, что у класса будет только один экземпляр, и предоставляет глобальную точку доступа к нему.
##### Factory Method
– это порождающий шаблон проектирования, который определяет интерфейс для создания объектов, но позволяет подклассам изменять тип создаваемых объектов.

**Структура паттерна Фабричный метод**
1. **Продукт (Product)**: Определяет интерфейс создаваемых объектов.
2. **Конкретный продукт (Concrete Product)**: Класс, который реализует интерфейс продукта.
3. **Создатель (Creator)**: Определяет фабричный метод, возвращающий объект продукта. Может быть абстрактным классом или интерфейсом.
4. **Конкретный создатель (Concrete Creator)**: Класс, который реализует фабричный метод, создавая конкретные объекты продуктов.
##### Abstract Factory
– это порождающий паттерн проектирования, который предоставляет интерфейс для создания семейств взаимосвязанных объектов, не привязываясь к конкретным классам. Этот паттерн позволяет создавать наборы объектов, которые должны использоваться вместе и взаимозаменяемы, а также дает возможность легко менять семейства объектов, не изменяя код клиента.

**Основные идеи паттерна Abstract Factory**
1. **Создание семейств объектов**: Паттерн позволяет создавать группы или семейства объектов, которые логически или функционально связаны. Например, в графическом интерфейсе приложения можно использовать различные стили (например, "Светлый" и "Тёмный"), где каждый стиль будет представлять собой набор виджетов (кнопок, полей, окон и т.д.).
2. **Гибкость в смене семейств**: Используя абстрактную фабрику, можно легко переключаться между различными наборами продуктов, не изменяя код клиента.
3. **Расширяемость**: Если нужно добавить новое семейство продуктов, можно создать новую реализацию абстрактной фабрики, не внося изменений в основной код приложения.

**Структура паттерна Abstract Factory**
1. **Абстрактная фабрика (Abstract Factory)**: Интерфейс, определяющий методы для создания различных типов продуктов (например, методы для создания кнопки, окна, текстового поля).
2. **Конкретная фабрика (Concrete Factory)**: Реализует интерфейс абстрактной фабрики для создания конкретных продуктов, принадлежащих одному семейству (например, фабрика для создания светлого или тёмного стилей).
3. **Абстрактный продукт (Abstract Product)**: Интерфейс или базовый класс для всех типов продуктов (например, интерфейсы для кнопки, окна).
4. **Конкретный продукт (Concrete Product)**: Реализация конкретного продукта, соответствующего одному семейству.
5. **Клиент (Client)**: Код, который использует абстрактную фабрику для создания продуктов. Клиент взаимодействует с абстрактными продуктами, что позволяет ему оставаться независимым от конкретных классов продуктов.
##### Builder

– это порождающий паттерн проектирования, который используется для создания сложных объектов пошагово. `Builder` позволяет собирать объект частями, контролируя каждый этап его создания. Этот паттерн особенно полезен, когда объект имеет множество опциональных параметров или требует сложной конфигурации. `Builder`помогает избежать избыточного числа конструкторов и делает код более гибким и читабельным.

**Основные идеи паттерна Builder**
1. **Пошаговое создание сложного объекта**: Позволяет задавать параметры объекта пошагово, а не сразу в конструкторе, упрощая конфигурацию.
2. **Инкапсуляция этапов создания**: Складывает процесс построения в отдельные методы, скрывая детали создания от клиента.
3. **Гибкость построения**: Паттерн позволяет создать различные представления одного объекта (например, разные конфигурации или части).

**Структура паттерна Builder**
1. **Строитель (Builder)**: Интерфейс или абстрактный класс, определяющий методы для поэтапного создания частей объекта.
2. **Конкретный строитель (Concrete Builder)**: Реализует интерфейс `Builder`, создавая конкретные части объекта и накапливая результат.
3. **Директор (Director)**: Опциональный класс, управляющий порядком шагов для создания объекта. Часто используется, если порядок действий фиксирован.
4. **Продукт (Product)**: Конечный объект, который строится при помощи `Builder`.
##### Prototype
— это порождающий шаблон проектирования, который позволяет копировать уже существующие объекты, не зависимо от их конкретных классов. В `Prototype` вместо создания нового объекта с помощью конструктора, создается его клон, что может быть полезно в случаях, когда создание объекта «с нуля» является сложным или затратным по ресурсам.

**Основные идеи паттерна Prototype**
1. **Клонирование объектов**: `Prototype` позволяет копировать объекты через клонирование, что упрощает и ускоряет создание экземпляров.
2. **Гибкость и независимость от классов**: Паттерн предоставляет возможность копировать объекты без привязки к их конкретным классам. При этом можно клонировать как простые, так и сложные объекты с вложенными структурами.
3. **Сокращение числа подклассов**: Вместо создания множества подклассов для конфигурации объекта, можно создать один базовый объект и копировать его, подстраивая под конкретные нужды.

**Структура паттерна Prototype**
1. **Прототип (Prototype)**: Интерфейс или абстрактный класс с методом `clone()`, который позволяет клонировать объект.
2. **Конкретный прототип (Concrete Prototype)**: Класс, реализующий метод `clone()` для создания копии объекта.
3. **Клиент (Client)**: Код, который вызывает `clone()` для создания нового объекта через клонирование.
##### Singleton 
– это порождающий шаблон проектирования, который гарантирует, что у класса будет только один экземпляр, и предоставляет глобальную точку доступа к этому экземпляру. `Singleton` позволяет контролировать создание объекта и делает его уникальным для всего приложения, что полезно в ситуациях, когда требуется единая точка контроля, например, для работы с конфигурацией или логированием.

**Основные идеи паттерна Singleton**
1. **Контроль над созданием экземпляра**: `Singleton` предотвращает создание более одного экземпляра класса, контролируя процесс создания.
2. **Глобальная точка доступа**: Паттерн предоставляет глобальный доступ к экземпляру класса, что позволяет легко управлять доступом к важным объектам.
3. **Удобство управления состоянием**: `Singleton` гарантирует, что все части приложения используют один и тот же объект, что упрощает управление состоянием.

**Структура паттерна Singleton**
1. **Сам Singleton**: Класс, который реализует собственное создание и предоставляет метод для получения экземпляра. В этом классе конструктор закрыт или ограничен, чтобы предотвратить создание новых экземпляров.
2. **Метод получения экземпляра (getInstance)**: Статический метод, который проверяет, был ли уже создан экземпляр, и если нет — создает его, возвращая ссылку на один и тот же объект при каждом вызове.
3. **Клиент (Client)**: Код, который использует `Singleton` и всегда получает ссылку на один и тот же экземпляр.

## Структурные
Эти паттерны помогают организовать классы и объекты в более крупные структуры.
- **Adapter (Адаптер)**: Позволяет объектам с несовместимыми интерфейсами работать вместе.
- **Bridge (Мост)**: Разделяет абстракцию и реализацию, чтобы они могли изменяться независимо.
- **Composite (Компоновщик)**: Позволяет сгруппировать объекты в древовидные структуры для представления иерархий «часть-целое».
- **Decorator (Декоратор)**: Динамически добавляет новые обязанности объектам, оборачивая их в другой объект.
- **Facade (Фасад)**: Предоставляет упрощённый интерфейс к сложной системе.
- **Flyweight (Приспособленец)**: Снижает затраты на создание большого числа похожих объектов за счёт разделения общего состояния.
- **Proxy (Заместитель)**: Предоставляет замену для другого объекта для контроля доступа к нему.
##### Adapter
— это структурный шаблон проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе. `Adapter` действует как промежуточное звено между двумя несовместимыми интерфейсами, преобразуя интерфейс одного класса в интерфейс, ожидаемый клиентом. Этот паттерн особенно полезен, когда нужно интегрировать существующие компоненты или системы без изменения их исходного кода.

**Основные идеи паттерна Adapter**
1. **Совместимость интерфейсов**: `Adapter` позволяет объектам с несовместимыми интерфейсами взаимодействовать друг с другом, что упрощает интеграцию.
2. **Переиспользование кода**: Паттерн позволяет использовать существующие классы, не изменяя их, что способствует повторному использованию кода.
3. **Инкапсуляция**: `Adapter` инкапсулирует логику преобразования, что упрощает клиентский код и делает его более читаемым.

**Структура паттерна Adapter**
1. **Целевой интерфейс (Target)**: Интерфейс, который клиент ожидает использовать. Это может быть интерфейс, описывающий необходимые методы для работы с клиентом.
2. **Адаптируемый класс (Adaptee)**: Класс, который имеет несовместимый интерфейс, но функциональность которого нужно использовать.
3. **Адаптер (Adapter)**: Класс, который реализует целевой интерфейс и содержит ссылку на адаптируемый класс. Он преобразует вызовы методов из целевого интерфейса в методы адаптируемого класса.
##### Bridge
— это структурный шаблон проектирования, который разделяет абстракцию и реализацию, позволяя изменять их независимо друг от друга. `Bridge` используется для разработки масштабируемых систем, где требуется гибкость и возможность расширения, так как он предотвращает создание множества подклассов для каждой комбинации абстракции и реализации.

**Основные идеи паттерна Bridge**
1. **Отделение абстракции от реализации**: `Bridge` позволяет отделить интерфейс и его реализацию, что упрощает изменение и расширение как абстракций, так и их реализаций.
2. **Упрощение кода**: Паттерн уменьшает количество подклассов, которые необходимо создать, за счет разделения интерфейсов и реализаций.
3. **Поддержка изменения реализации**: Позволяет изменять реализацию без необходимости изменения абстракции, что делает систему более гибкой.

**Структура паттерна Bridge**
1. **Абстракция (Abstraction)**: Определяет общий интерфейс для клиентов и содержит ссылку на объект реализации.
2. **Расширенная абстракция (Refined Abstraction)**: Реализует дополнительные функции абстракции и использует объект реализации.
3. **Реализация (Implementation)**: Определяет интерфейс, который будет реализован конкретными классами.
4. **Конкретная реализация (Concrete Implementation)**: Классы, реализующие интерфейс реализации.
##### Composite
— это структурный шаблон проектирования, который позволяет объединить объекты в древовидную структуру для представления иерархий «часть-целое». `Composite` позволяет клиентам работать с отдельными объектами и составными объектами (композитами) единообразно. Этот паттерн удобен, когда необходимо работать с иерархическими структурами данных, такими как графические объекты, файловые системы и т.д.

**Основные идеи паттерна Composite**
1. **Единообразный интерфейс**: `Composite` предоставляет общий интерфейс для работы с отдельными объектами и составными объектами, что упрощает код клиента.
2. **Динамическое создание иерархий**: Паттерн позволяет динамически создавать сложные иерархии объектов, добавляя и удаляя их в любое время.
3. **Упрощение клиентского кода**: Клиенты могут взаимодействовать с объектами, не беспокоясь о том, являются ли они простыми или составными.

**Структура паттерна Composite**
1. **Компонент (Component)**: Абстрактный класс или интерфейс, определяющий общий интерфейс для всех объектов (как для простых, так и для составных).
2. **Лист (Leaf)**: Конкретный класс, представляющий конечные объекты, которые не имеют дочерних объектов.
3. **Композит (Composite)**: Конкретный класс, который содержит дочерние компоненты (листы и другие композиты) и реализует операции для управления этими дочерними компонентами.
##### Decorator
— это структурный шаблон проектирования, который позволяет динамически добавлять объектам новые функциональности, оборачивая их в «обертки». Паттерн `Decorator` предоставляет гибкий способ расширения поведения объектов без изменения их структуры, что делает его полезным для реализации функций, которые могут быть добавлены по мере необходимости.

**Основные идеи паттерна Decorator**
1. **Динамическое добавление функциональности**: `Decorator` позволяет добавлять дополнительные обязанности объектам на лету.
2. **Упрощение кода**: Вместо создания множества подклассов для каждого сочетания поведения, можно создать один базовый класс и различные декораторы для добавления функциональности.
3. **Поддержка открытости/закрытости**: Паттерн следует принципу открытости/закрытости (Open/Closed Principle), позволяя расширять функциональность без изменения существующих классов.

**Структура паттерна Decorator**
1. **Компонент (Component)**: Абстрактный класс или интерфейс, определяющий общий интерфейс для всех объектов, которые могут иметь дополнительную функциональность.
2. **Конкретный компонент (Concrete Component)**: Класс, реализующий интерфейс компонента и представляющий основной объект.
3. **Декоратор (Decorator)**: Абстрактный класс, который содержит ссылку на компонент и реализует общий интерфейс. Декоратор может добавлять дополнительную функциональность.
4. **Конкретные декораторы (Concrete Decorators)**: Классы, наследуемые от декоратора, которые добавляют новые функции к компоненту.
##### Facade
– это структурный шаблон проектирования, который предоставляет упрощенный интерфейс для сложной подсистемы. Паттерн `Facade` скрывает сложность системы, предлагая более простой и единообразный интерфейс для клиента, что делает взаимодействие с системой более удобным и понятным.

**Основные идеи паттерна Facade**
1. **Упрощение интерфейса**: `Facade` предлагает простой интерфейс, который облегчает использование сложной системы.
2. **Сокрытие сложности**: Паттерн скрывает сложные детали взаимодействия между классами подсистемы, позволяя клиенту сосредоточиться на основной логике.
3. **Снижение зависимости**: Использование фасада помогает уменьшить зависимость клиентского кода от сложной системы, что упрощает сопровождение и модификацию кода.

**Структура паттерна Facade**
1. **Фасад (Facade)**: Класс, предоставляющий простой интерфейс для взаимодействия с подсистемой. Он делегирует вызовы соответствующим классам подсистемы.
2. **Подсистема (Subsystem Classes)**: Классы, представляющие сложную логику системы, с которой будет взаимодействовать фасад. Эти классы могут быть сложными и взаимосвязанными.
##### Flyweight
— это структурный шаблон проектирования, который позволяет уменьшить количество создаваемых объектов, разделяя их между собой. Паттерн `Flyweight` используется для оптимизации использования памяти и повышения производительности, особенно когда речь идет о большом количестве объектов с одинаковыми состояниями.

**Основные идеи паттерна Flyweight**
1. **Разделение состояний**: Паттерн разделяет объекты на две категории: внутренние (несменяемые) и внешние (изменяемые) состояния. Внутренние состояния могут быть общими для множества объектов, в то время как внешние состояния могут варьироваться от объекта к объекту.
2. **Уменьшение затрат на память**: За счет использования единого экземпляра общего состояния можно существенно сократить количество объектов, что позволяет сэкономить память.
3. **Оптимизация производительности**: Снижая нагрузку на систему за счет уменьшения количества создаваемых объектов, паттерн может повысить общую производительность приложения.

**Структура паттерна Flyweight**
1. **Флайвейт (Flyweight)**: Интерфейс или абстрактный класс, который объявляет методы для работы с внешними состояниями.
2. **Конкретный флайвейт (Concrete Flyweight)**: Реализация интерфейса флайвейта, содержащая внутреннее состояние.
3. **Фабрика флайвэйтов (Flyweight Factory)**: Класс, который отвечает за создание и управление флайвэйтами. Он обеспечивает повторное использование существующих флайвэйтов и создает новые, только если это необходимо.
4. **Клиент (Client)**: Код, который использует флайвэйты. Клиент может хранить внешние состояния объектов.
##### Proxy
— это структурный шаблон проектирования, который предоставляет суррогатный или заместительный объект, который управляет доступом к другому объекту. Паттерн `Proxy` позволяет контролировать доступ к объекту, добавляя дополнительные действия, такие как управление правами доступа, ведение журналов, кэширование и другие функции.

**Основные идеи паттерна Proxy**
1. **Управление доступом**: `Proxy` позволяет контролировать доступ к объекту, добавляя уровень абстракции между клиентом и реальным объектом.
2. **Отложенная инициализация**: Proxy может создавать объект только тогда, когда он действительно нужен, что позволяет экономить ресурсы.
3. **Дополнительные функции**: Proxy может добавлять дополнительную функциональность, такую как логирование, кэширование и контроль доступа, без изменения кода самого объекта.

**Структура паттерна Proxy**
1. **Субъект (Subject)**: Интерфейс или абстрактный класс, который определяет общий интерфейс для реального объекта и прокси.
2. **Реальный субъект (Real Subject)**: Конкретный класс, который реализует интерфейс субъекта и содержит основную логику.
3. **Прокси (Proxy)**: Класс, который реализует интерфейс субъекта и содержит ссылку на реальный объект. Прокси управляет доступом к реальному объекту.

## Поведенческие
Эти паттерны помогают организовать взаимодействие между объектами и распределение обязанностей.
- **Chain of Responsibility (Цепочка обязанностей)**: Передает запрос по цепочке обработчиков, пока не найдется подходящий.
- **Command (Команда)**: Инкапсулирует запрос в виде объекта, позволяя передавать его как параметр.
- **Interpreter (Интерпретатор)**: Определяет грамматику и интерпретирует предложения в этом языке.
- **Iterator (Итератор)**: Предоставляет способ последовательного доступа к элементам коллекции.
- **Mediator (Посредник)**: Устраняет прямые связи между взаимодействующими объектами, предоставляя их через посредника.
- **Memento (Хранитель)**: Сохраняет состояние объекта для возможности его восстановления позже.
- **Observer (Наблюдатель)**: Создаёт механизм подписки для того, чтобы одни объекты могли отслеживать изменения других.
- **State (Состояние)**: Позволяет объекту изменять своё поведение при изменении его внутреннего состояния.
- **Strategy (Стратегия)**: Определяет семейство алгоритмов, которые можно менять в зависимости от ситуации.
- **Template Method (Шаблонный метод)**: Определяет алгоритм, позволяя подклассам переопределить некоторые его шаги.
- **Visitor (Посетитель)**: Позволяет добавлять новые операции к объектам без изменения их классов.
##### Chain of Responsibility 
— это поведенческий шаблон проектирования, который позволяет избежать жесткой привязки между отправителем и получателем запроса. Паттерн создает цепочку обработчиков, через которую проходит запрос, и каждый обработчик может обработать запрос сам или передать его дальше по цепочке. Это позволяет разделить ответственность и обеспечивает гибкость в обработке запросов.

**Основные идеи паттерна Chain of Responsibility**
1. **Отделение отправителя от получателя**: Паттерн позволяет отправителю не знать, кто именно обработает его запрос, обеспечивая таким образом слабую связь между объектами.
2. **Цепочка обработчиков**: Каждый обработчик имеет ссылку на следующий обработчик в цепочке и решает, передавать ли запрос дальше.
3. **Гибкость в добавлении новых обработчиков**: Можно легко добавлять новые обработчики в цепочку, не изменяя существующий код.

**Структура паттерна Chain of Responsibility**
1. **Обработчик (Handler)**: Интерфейс или абстрактный класс, определяющий метод для обработки запроса и ссылку на следующий обработчик в цепочке.
2. **Конкретные обработчики (Concrete Handlers)**: Классы, которые реализуют интерфейс обработчика и обрабатывают запрос или передают его дальше.
3. **Клиент (Client)**: Код, который создает цепочку обработчиков и отправляет запросы.
##### Command
— это поведенческий шаблон проектирования, который инкапсулирует запрос в виде объекта, позволяя параметризовать клиентов с различными запросами, ставить запросы в очередь или записывать их, а также поддерживать операцию отмены. Паттерн `Command` отделяет отправителя запроса от его получателя, предоставляя гибкость в управлении операциями.

**Основные идеи паттерна Command**
1. **Инкапсуляция запросов**: Каждый запрос представляется как отдельный объект, что позволяет использовать его как параметр.
2. **Поддержка отмены операций**: Позволяет реализовать возможность отмены и повтора операций.
3. **Отложенное выполнение**: Запросы могут быть выполнены позже, что позволяет создавать системы с отложенными действиями.

**Структура паттерна Command**
1. **Команда (Command)**: Интерфейс или абстрактный класс, определяющий метод для выполнения операции.
2. **Конкретные команды (Concrete Command)**: Классы, реализующие интерфейс команды и определяющие действия, которые будут выполнены.
3. **Получатель (Receiver)**: Класс, который знает, как выполнять операции, связанные с запросом.
4. **Инвокер (Invoker)**: Класс, который вызывает команды. Он хранит ссылки на команды и инициирует выполнение.
5. **Клиент (Client)**: Код, который создает объекты команд и настраивает их, связывая команды с получателями.
##### Interpreter
**Interpreter** — это поведенческий шаблон проектирования, который позволяет определить грамматику для определенного языка и предоставляет механизм для интерпретации предложений этого языка. Паттерн `Interpreter` используется для обработки и выполнения инструкций, представленных в виде объектов, и позволяет создавать интерпретаторы для различных языков.

**Основные идеи паттерна Interpreter**

1. **Определение грамматики**: Паттерн позволяет определить грамматику языка в виде классов, каждый из которых соответствует определенному элементу языка.
2. **Интерпретация выражений**: Каждый класс предоставляет метод интерпретации, который выполняет действие, связанное с этим элементом языка.
3. **Составные выражения**: Позволяет комбинировать простые выражения в более сложные, обеспечивая гибкость в создании и обработке выражений.

**Структура паттерна Interpreter**

1. **Интерпретатор (Expression)**: Интерфейс или абстрактный класс, который определяет метод для интерпретации выражений.
2. **Листовые узлы (Terminal Expression)**: Конкретные классы, представляющие терминальные элементы языка, которые могут быть интерпретированы непосредственно.
3. **Нетеровые узлы (Non-terminal Expression)**: Конкретные классы, представляющие составные выражения, которые могут содержать другие узлы.
4. **Клиент (Client)**: Код, который создает выражения и инициирует их интерпретацию.
##### Iterator
— это поведенческий шаблон проектирования, который предоставляет способ последовательного доступа к элементам составного объекта, не раскрывая его внутреннюю структуру. Паттерн `Iterator` позволяет обходить элементы коллекции, сохраняя при этом состояние итерации.

**Основные идеи паттерна Iterator**
1. **Отделение логики обхода**: Итератор отделяет логику обхода коллекции от самой коллекции, что позволяет изменять структуру коллекции, не влияя на код, использующий итератор.
2. **Упрощение доступа**: Позволяет получать доступ к элементам коллекции по одному, не требуя знания о внутреннем устройстве коллекции.
3. **Поддержка различных коллекций**: Один и тот же итератор может быть использован для обхода различных типов коллекций.

**Структура паттерна Iterator**
1. **Итератор (Iterator)**: Интерфейс, определяющий методы для обхода элементов (например, `Next`, `HasNext`, `Current`).
2. **Конкретный итератор (Concrete Iterator)**: Реализация интерфейса итератора, которая отслеживает текущее положение в коллекции.
3. **Коллекция (Aggregate)**: Интерфейс для создания итератора.
4. **Конкретная коллекция (Concrete Aggregate)**: Реализация интерфейса коллекции, которая создает итератор.
##### Mediator
— это поведенческий шаблон проектирования, который позволяет уменьшить связанность между объектами, позволяя им взаимодействовать через единую посредническую сущность. Паттерн `Mediator` способствует снижению зависимости между компонентами системы, упрощая взаимодействие и повышая гибкость кода.

**Основные идеи паттерна Mediator**
1. **Уменьшение связанности**: Компоненты не общаются друг с другом напрямую, а взаимодействуют через посредника, что снижает степень их взаимозависимости.
2. **Централизованное управление**: Посредник контролирует взаимодействия между компонентами, обеспечивая единое место для изменения логики взаимодействия.
3. **Упрощение системы**: Упрощает архитектуру системы, уменьшает сложность и облегчает тестирование.

**Структура паттерна Mediator**

1. **Посредник (Mediator)**: Интерфейс или абстрактный класс, определяющий методы для взаимодействия с компонентами.
2. **Конкретный посредник (Concrete Mediator)**: Реализация интерфейса посредника, которая содержит ссылки на компоненты и управляет их взаимодействием.
3. **Компоненты (Colleagues)**: Объекты, которые взаимодействуют через посредника. Они знают о посреднике, но не знают о других компонентах.
##### Memento
— это поведенческий шаблон проектирования, который позволяет сохранять и восстанавливать состояние объекта без раскрытия его внутренней структуры. Паттерн `Memento` используется для реализации механизма отмены и восстановления состояний, что позволяет работать с изменяемыми объектами, сохраняя их предыдущее состояние.

**Основные идеи паттерна Memento**
1. **Сохранение состояния**: Позволяет сохранять внутреннее состояние объекта в момент времени, чтобы его можно было восстановить позже.
2. **Инкапсуляция состояния**: Состояние объекта хранится в отдельном объекте (memento), что предотвращает прямой доступ к внутренним данным.
3. **Управление состоянием**: Предоставляет средства для управления состояниями, позволяя создавать механизмы отмены и восстановления.

**Структура паттерна Memento**
1. **Хранитель (Memento)**: Объект, который хранит внутреннее состояние другого объекта.
2. **Производитель (Originator)**: Объект, состояние которого необходимо сохранить. Он создает и восстанавливает хранитель.
3. **Наблюдатель (Caretaker)**: Объект, который управляет хранителями, сохраняя и восстанавливая состояние, но не изменяя его.
##### Observer
— это поведенческий шаблон проектирования, который определяет зависимость один ко многим между объектами так, что при изменении состояния одного объекта все зависимые объекты уведомляются и автоматически обновляются. Паттерн `Observer` часто используется в ситуациях, когда необходимо оповестить несколько объектов об изменении состояния другого объекта без жесткой связности между ними.

**Основные идеи паттерна Observer**
1. **Наблюдатели и субъекты**: Объект, который отслеживает изменения (наблюдатель), подписывается на события другого объекта (субъект), который изменяет свое состояние.
2. **Автоматическое обновление**: При изменении состояния субъекта все зарегистрированные наблюдатели получают уведомление и могут обновить свое состояние.
3. **Слабая связанность**: Наблюдатели и субъекты не зависят друг от друга, что позволяет легко добавлять или удалять наблюдателей.

**Структура паттерна Observer**
1. **Субъект (Subject)**: Интерфейс или абстрактный класс, который определяет методы для добавления, удаления и уведомления наблюдателей.
2. **Конкретный субъект (Concrete Subject)**: Реализация интерфейса субъекта, которая хранит состояние и уведомляет наблюдателей об изменениях.
3. **Наблюдатель (Observer)**: Интерфейс, который определяет метод для получения обновлений от субъекта.
4. **Конкретный наблюдатель (Concrete Observer)**: Реализация интерфейса наблюдателя, который обновляет свое состояние в ответ на уведомления.
##### State
— это поведенческий шаблон проектирования, который позволяет объекту изменять свое поведение в зависимости от его внутреннего состояния. Паттерн `State` позволяет объекту выглядеть так, как будто он изменяет свой класс, управляя состояниями и поведением объекта в каждой из них.

**Основные идеи паттерна State**
1. **Изменение поведения**: Объект может изменять свое поведение в зависимости от текущего состояния, что упрощает управление логикой.
2. **Отделение состояний**: Каждое состояние представляется отдельным классом, что упрощает добавление новых состояний и изменение логики.
3. **Упрощение кода**: Паттерн помогает избегать сложных условных операторов, перемещая логику состояний в соответствующие классы.

**Структура паттерна State**
1. **Контекст (Context)**: Класс, который содержит текущее состояние и делегирует действия состояниям.
2. **Состояние (State)**: Интерфейс или абстрактный класс, который определяет методы, которые могут быть реализованы конкретными состояниями.
3. **Конкретные состояния (Concrete States)**: Реализации интерфейса состояния, которые реализуют поведение для каждого состояния.
##### Strategy
— это поведенческий шаблон проектирования, который позволяет выбирать алгоритмы или стратегии поведения на этапе выполнения программы. Паттерн `Strategy` определяет набор алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми. Это позволяет изменять поведение объекта, не изменяя его код, а лишь изменяя используемую стратегию.

**Основные идеи паттерна Strategy**
1. **Инкапсуляция алгоритмов**: Алгоритмы инкапсулируются в отдельных классах, что облегчает их замену и изменение.
2. **Поддержка открытости и закрытости**: Новые стратегии могут добавляться без изменения существующего кода.
3. **Гибкость**: Позволяет динамически изменять поведение объекта, выбирая подходящую стратегию в зависимости от контекста.

**Структура паттерна Strategy**
1. **Контекст (Context)**: Класс, который использует стратегию. Он содержит ссылку на объект стратегии и делегирует выполнение операций этому объекту.
2. **Стратегия (Strategy)**: Интерфейс или абстрактный класс, который определяет методы, которые должны реализовывать конкретные стратегии.
3. **Конкретные стратегии (Concrete Strategies)**: Реализации интерфейса стратегии, каждая из которых содержит конкретный алгоритм.
##### Template Method
— это поведенческий шаблон проектирования, который определяет общий скелет алгоритма в методе, оставляя некоторые шаги для реализации в подклассах. Паттерн `Template Method` позволяет подклассам переопределять определенные шаги алгоритма, не изменяя его структуры. Этот подход способствует повторному использованию кода и снижению дублирования.

**Основные идеи паттерна Template Method**
1. **Определение алгоритма**: Алгоритм задается в базовом классе, в котором определяются последовательность шагов.
2. **Расширяемость**: Подклассы могут изменять некоторые шаги алгоритма, предоставляя свою реализацию, что обеспечивает гибкость.
3. **Сокрытие деталей**: Базовый класс управляет общими аспектами алгоритма, тогда как конкретные детали делегируются подклассам.

**Структура паттерна Template Method**
1. **Шаблонный метод (Template Method)**: Метод в базовом классе, который определяет последовательность шагов алгоритма.
2. **Базовый класс (Abstract Class)**: Определяет шаблонный метод и абстрактные методы (или методы с общим поведением), которые должны быть реализованы в подклассах.
3. **Конкретные классы (Concrete Classes)**: Подклассы, реализующие специфические шаги алгоритма.
##### Visitor
— это поведенческий шаблон проектирования, который позволяет добавлять новые операции к объектам, не изменяя их структуры. Паттерн `Visitor` используется для отделения алгоритмов от объектов, над которыми они работают, что упрощает добавление новых операций и поддержку кода.

**Основные идеи паттерна Visitor**
1. **Отделение операций от объектов**: Алгоритмы реализуются в отдельных классах, что позволяет избежать изменения классов объектов.
2. **Расширяемость**: Новый функционал можно добавлять без изменения существующих классов, просто создавая новые классы посетителей.
3. **Поддержка разных типов объектов**: Паттерн позволяет работать с различными типами объектов в едином контексте.

**Структура паттерна Visitor**
1. **Посетитель (Visitor)**: Интерфейс, который определяет методы для обработки каждого типа элемента.
2. **Конкретный посетитель (Concrete Visitor)**: Реализация интерфейса посетителя, содержащая логику для обработки конкретных элементов.
3. **Элемент (Element)**: Интерфейс, определяющий метод, принимающий посетителя.
4. **Конкретные элементы (Concrete Elements)**: Реализации интерфейса элемента, которые вызывают метод посетителя.



